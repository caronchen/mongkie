/*
 *  This file is part of MONGKIE. Visit <http://www.mongkie.org/> for details.
 *  Copyright (C) 2012 Korean Bioinformation Center(KOBIC)
 * 
 *  MONGKIE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 * 
 *  MONGKE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 * 
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.mongkie.ui.datatable.graph.actions.edge;

import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.lang.reflect.InvocationTargetException;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import javax.swing.DefaultComboBoxModel;
import javax.swing.Icon;
import javax.swing.JPanel;
import kobic.prefuse.Constants;
import kobic.prefuse.display.DataEditSupport;
import org.jdesktop.swingx.icon.EmptyIcon;
import org.mongkie.datatable.spi.DataAction;
import org.mongkie.ui.datatable.graph.AbstractDataTable;
import org.mongkie.visualization.MongkieDisplay;
import org.openide.NotifyDescriptor;
import org.openide.explorer.propertysheet.PropertySheet;
import org.openide.nodes.Node.Property;
import org.openide.nodes.*;
import org.openide.util.ImageUtilities;
import prefuse.Visualization;
import prefuse.data.Graph;
import prefuse.data.Table;
import prefuse.data.Tuple;
import prefuse.data.column.Column;
import prefuse.data.tuple.TupleSet;
import prefuse.data.util.Sort;
import prefuse.util.StringLib;
import prefuse.visual.VisualItem;

/**
 *
 * @author Yeongjun Jang <yjjang@kribb.re.kr>
 */
public class AddEdgeUI extends javax.swing.JPanel implements DataAction.UI<AbstractDataTable, AddEdge>, ItemListener {

    private AddEdge action;
    private final Map<String, Object> tupleData = new LinkedHashMap<String, Object>();

    /**
     * Creates new form AddEdgeUI
     */
    private AddEdgeUI() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        sourceLabel = new javax.swing.JLabel();
        sourceComboBox = new javax.swing.JComboBox();
        targetLabel = new javax.swing.JLabel();
        targetComboBox = new javax.swing.JComboBox();
        propertySheet = new PropertySheet();
        ((PropertySheet) propertySheet).setDescriptionAreaVisible(false);

        setPreferredSize(new java.awt.Dimension(318, 192));
        setRequestFocusEnabled(false);

        sourceLabel.setText(org.openide.util.NbBundle.getMessage(AddEdgeUI.class, "AddEdgeUI.sourceLabel.text")); // NOI18N

        targetLabel.setText(org.openide.util.NbBundle.getMessage(AddEdgeUI.class, "AddEdgeUI.targetLabel.text")); // NOI18N

        propertySheet.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(sourceLabel)
                            .addComponent(targetLabel))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(targetComboBox, 0, 236, Short.MAX_VALUE)
                            .addComponent(sourceComboBox, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                    .addComponent(propertySheet, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(sourceLabel)
                    .addComponent(sourceComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(targetLabel)
                    .addComponent(targetComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(propertySheet, javax.swing.GroupLayout.DEFAULT_SIZE, 98, Short.MAX_VALUE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel propertySheet;
    private javax.swing.JComboBox sourceComboBox;
    private javax.swing.JLabel sourceLabel;
    private javax.swing.JComboBox targetComboBox;
    private javax.swing.JLabel targetLabel;
    // End of variables declaration//GEN-END:variables

    @Override
    public void load(AbstractDataTable table, AddEdge action) {
        this.action = action;
        this.display = table.getModel().getDisplay();
        Graph g = table.getModel().getGraph();
        String nodeLabelField = g.getNodeLabelField();
        for (Iterator<Tuple> nodesIter = (nodeLabelField == null)
                ? g.getNodeTable().tuples() : g.getNodeTable().tuples(null, new Sort(new String[]{nodeLabelField}));
                nodesIter.hasNext();) {
            TupleLabel nlabel = new TupleLabel(nodesIter.next(), nodeLabelField);
            sourceComboBox.addItem(nlabel);
            targetComboBox.addItem(nlabel);
        }
        sourceComboBox.setSelectedIndex(0);
        targetComboBox.setSelectedIndex(0);
        originalSelection = display.getVisualization().getFocusGroup(Visualization.FOCUS_ITEMS).toArray();
        sourceComboBox.addItemListener(this);
        targetComboBox.addItemListener(this);
        ((PropertySheet) propertySheet).setNodes(new Node[]{new TupleNode(table.getModel().getTable(), g)});
    }
    private Tuple[] originalSelection;

    @Override
    public void itemStateChanged(ItemEvent e) {
        if (e.getStateChange() == ItemEvent.SELECTED) {
            final Visualization v = display.getVisualization();
            final VisualItem source = v.getVisualItem(Constants.NODES, ((TupleLabel) sourceComboBox.getSelectedItem()).getTuple());
            final VisualItem target = v.getVisualItem(Constants.NODES, ((TupleLabel) targetComboBox.getSelectedItem()).getTuple());
            v.process(new Runnable() {
                @Override
                public void run() {
                    TupleSet focusedTupleSet = v.getFocusGroup(Visualization.FOCUS_ITEMS);
                    focusedTupleSet.clear();
                    focusedTupleSet.addTuple(source);
                    focusedTupleSet.addTuple(target);
                }
            }, Visualization.DRAW);
            panDisplayCenterTo(e.getSource() == sourceComboBox ? source : target);
        }
    }
    private MongkieDisplay display;

    private void panDisplayCenterTo(VisualItem item) {
        double displayX = display.getDisplayX();
        double displayY = display.getDisplayY();
        double scale = display.getScale();
        double itemX = item.getBounds().getCenterX() * scale;
        double itemY = item.getBounds().getCenterY() * scale;
        double screenWidth = display.getWidth();
        double screenHeight = display.getHeight();
        double moveX = (itemX * -1) + ((screenWidth / 2) + displayX);
        double moveY = (itemY * -1) + ((screenHeight / 2) + displayY);
        display.animatePan(moveX, moveY, 1000);
    }

    @Override
    public boolean close(Object option) {
        boolean ok = option.equals(NotifyDescriptor.OK_OPTION);
        action.setSourceAndTarget(
                ok ? ((TupleLabel) sourceComboBox.getSelectedItem()).getTuple() : null,
                ok ? ((TupleLabel) targetComboBox.getSelectedItem()).getTuple() : null);
        action.setTupleData(ok ? tupleData : null);
        if (!ok) {
            display.getVisualization().process(new Runnable() {
                @Override
                public void run() {
                    TupleSet focusedTupleSet = display.getVisualization().getFocusGroup(Visualization.FOCUS_ITEMS);
                    focusedTupleSet.clear();
                    for (Tuple t : originalSelection) {
                        focusedTupleSet.addTuple(t);
                    }
                }
            }, Visualization.DRAW);
        }
        originalSelection = null;
        sourceComboBox.removeItemListener(this);
        targetComboBox.removeItemListener(this);
        ((DefaultComboBoxModel) sourceComboBox.getModel()).removeAllElements();
        ((DefaultComboBoxModel) targetComboBox.getModel()).removeAllElements();
        tupleData.clear();
        ((PropertySheet) propertySheet).setNodes(new Node[]{});
        display = null;
        return ok;
    }

    @Override
    public JPanel getPanel() {
        return this;
    }

    static AddEdgeUI getInstance() {
        return Holder.UI;
    }

    @Override
    public Object[] getDialogOptions() {
        return null;
    }

    private static class Holder {

        private static final AddEdgeUI UI = new AddEdgeUI();
    }

    private static class TupleLabel {

        private final Tuple tuple;
        private final String labelField;

        TupleLabel(Tuple tuple, String labelField) {
            this.tuple = tuple;
            this.labelField = labelField;
        }

        Tuple getTuple() {
            return tuple;
        }

        @Override
        public String toString() {
            return labelField == null ? String.valueOf(tuple.getRow()) : tuple.getString(labelField);
        }
    }

    private class TupleNode extends AbstractNode {

        private final Table table;
        private final String labelField;

        public TupleNode(Table table, Graph g) {
            super(Children.LEAF);
            this.table = table;
            this.labelField = g.getEdgeLabelField();
            assert tupleData.isEmpty();
            for (int i = 0; i < table.getColumnCount(); i++) {
                String col = table.getColumnName(i);
                if (!col.equals(g.getEdgeSourceField()) && !col.equals(g.getEdgeTargetField())) {
                    tupleData.put(col, table.getDefault(col));
                }
            }
        }

        @Override
        protected Sheet createSheet() {
            Sheet sheet = Sheet.createDefault();
            Sheet.Set attributes = Sheet.createPropertiesSet();
            attributes.setDisplayName("Data fields");
            for (final String field : tupleData.keySet()) {
                Property p = new PropertySupport.ReadWrite(field,
                        ((DataEditSupport) table.getClientProperty(DataEditSupport.PROP_KEY)).getColumnType(field),
                        null, null) {
                    @Override
                    public Object getValue() throws IllegalAccessException, InvocationTargetException {
                        Object val = tupleData.get(field);
                        if (val != null && table.getMetadata(field).hasMultipleValues()) {
                            val = ((String) val).split(Column.MULTI_VAL_SEPARATOR);
                        }
                        return val;
                    }

                    @Override
                    public void setValue(Object val) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
                        if (val != null && table.getMetadata(field).hasMultipleValues()) {
                            tupleData.put(field, StringLib.concatStringArray((String[]) val, Column.MULTI_VAL_SEPARATOR));
                        } else {
                            tupleData.put(field, val);
                        }
                    }
                };
                p.setValue("nameIcon", field.equals(labelField)
                        ? ImageUtilities.loadImageIcon("org/mongkie/ui/datatable/resources/tag-label-black.png", false) : EMPTY_ICON);
                attributes.put(p);
            }
            sheet.put(attributes);
            return sheet;
        }
        private final Icon EMPTY_ICON = new EmptyIcon(16, 16);
    }
}
