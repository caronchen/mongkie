/*
 *  This file is part of MONGKIE. Visit <http://www.mongkie.org/> for details.
 *  Copyright (C) 2012 Korean Bioinformation Center(KOBIC)
 * 
 *  MONGKIE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 * 
 *  MONGKE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 * 
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.mongkie.ui.datatable.graph.actions.node;

import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.Map;
import javax.swing.Icon;
import javax.swing.JPanel;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.BadLocationException;
import kobic.prefuse.display.DataEditSupport;
import org.jdesktop.swingx.icon.EmptyIcon;
import org.mongkie.datatable.spi.DataAction;
import org.mongkie.ui.datatable.graph.AbstractDataTable;
import org.netbeans.validation.api.builtin.stringvalidation.StringValidators;
import org.netbeans.validation.api.ui.ValidationGroup;
import org.netbeans.validation.api.ui.swing.ValidationPanel;
import org.openide.explorer.propertysheet.PropertySheet;
import org.openide.nodes.*;
import org.openide.util.Exceptions;
import org.openide.util.ImageUtilities;
import prefuse.data.Table;
import prefuse.data.column.Column;
import prefuse.util.StringLib;

/**
 *
 * @author Yeongjun Jang <yjjang@kribb.re.kr>
 */
public class AddNodeUI extends javax.swing.JPanel implements DataAction.UI<AbstractDataTable, AddNode> {

    private AddNode action;
    private final Map<String, Object> tupleData = new HashMap<String, Object>();
    private TupleNode tupleNode;

    /** Creates new form AddNodeUI */
    private AddNodeUI() {
        initComponents();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        labelLabel = new javax.swing.JLabel();
        labelText = new javax.swing.JTextField();
        propertySheet = new PropertySheet();
        ((PropertySheet) propertySheet).setDescriptionAreaVisible(false);

        setPreferredSize(new java.awt.Dimension(318, 162));

        labelLabel.setText(org.openide.util.NbBundle.getMessage(AddNodeUI.class, "AddNodeUI.labelLabel.text")); // NOI18N

        labelText.setText(org.openide.util.NbBundle.getMessage(AddNodeUI.class, "AddNodeUI.labelText.text")); // NOI18N
        labelText.setName(org.openide.util.NbBundle.getMessage(AddNodeUI.class, "AddNodeUI.labelText.name")); // NOI18N

        propertySheet.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(propertySheet, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(labelLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(labelText, javax.swing.GroupLayout.DEFAULT_SIZE, 245, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(labelLabel)
                    .addComponent(labelText, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(propertySheet, javax.swing.GroupLayout.DEFAULT_SIZE, 100, Short.MAX_VALUE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel labelLabel;
    private javax.swing.JTextField labelText;
    private javax.swing.JPanel propertySheet;
    // End of variables declaration//GEN-END:variables

    @Override
    public void load(AbstractDataTable table, AddNode action) {
        this.action = action;
        String labelField = table.getModel().getGraph().getNodeLabelField();
        ((PropertySheet) propertySheet).setNodes(
                new Node[]{tupleNode = new TupleNode(table.getModel().getTable(), labelField)});
        if (labelField != null) {
            labelText.getDocument().addDocumentListener(tupleNode);
        }
        labelText.requestFocusInWindow();
    }

    @Override
    public boolean apply(boolean ok) {
        if (ok) {
            action.setNodeLabel(labelText.getText());
            action.setTupleData(tupleData);
        }
        labelText.getDocument().removeDocumentListener(tupleNode);
        labelText.setText(null);
        tupleData.clear();
        return ok;
    }

    @Override
    public JPanel getPanel() {
        if (validationPanel == null) {
            validationPanel = new ValidationPanel();
            validationPanel.setInnerComponent(this);
            ValidationGroup validationGroup = validationPanel.getValidationGroup();
            validationGroup.add(labelText, StringValidators.REQUIRE_NON_EMPTY_STRING);
        }
        return validationPanel;
    }
    private ValidationPanel validationPanel;

    static AddNodeUI getInstance() {
        return Holder.UI;
    }

    private static class Holder {

        private static final AddNodeUI UI = new AddNodeUI();
    }

    private class TupleNode extends AbstractNode implements DocumentListener {

        private final Table table;
        private final String labelField;

        public TupleNode(Table table, String labelField) {
            super(Children.LEAF);
            this.table = table;
            this.labelField = labelField;
            assert tupleData.isEmpty();
            for (int i = 0; i < table.getColumnCount(); i++) {
                String col = table.getColumnName(i);
                tupleData.put(col, table.getDefault(col));
            }
        }

        @Override
        protected Sheet createSheet() {
            Sheet sheet = Sheet.createDefault();
            Sheet.Set attributes = Sheet.createPropertiesSet();
            attributes.setDisplayName("Data fields");
            for (final String field : tupleData.keySet()) {
                Property p = new PropertySupport.ReadWrite(field,
                        ((DataEditSupport) table.getClientProperty(DataEditSupport.PROP_KEY)).getColumnType(field),
                        null, null) {

                    @Override
                    public Object getValue() throws IllegalAccessException, InvocationTargetException {
                        Object val = tupleData.get(field);
                        if (val != null && table.getMetadata(field).hasMultipleValues()) {
                            val = ((String) val).split(Column.MULTI_VAL_SEPARATOR);
                        }
                        return val;
                    }

                    @Override
                    public void setValue(Object val) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
                        if (val != null && table.getMetadata(field).hasMultipleValues()) {
                            tupleData.put(field, StringLib.concatStringArray((String[]) val, Column.MULTI_VAL_SEPARATOR));
                        } else {
                            tupleData.put(field, val);
                        }
                        if (field.equals(labelField)) {
                            labelText.setText((String) val);
                        }
                    }
                };
                p.setValue("nameIcon", field.equals(labelField)
                        ? ImageUtilities.loadImageIcon("org/mongkie/ui/datatable/resources/tag-label-black.png", false) : EMPTY_ICON);
                attributes.put(p);
            }
            sheet.put(attributes);
            return sheet;
        }
        private final Icon EMPTY_ICON = new EmptyIcon(16, 16);

        @Override
        public void insertUpdate(DocumentEvent e) {
            changedUpdate(e);
        }

        @Override
        public void removeUpdate(DocumentEvent e) {
            changedUpdate(e);
        }

        @Override
        public void changedUpdate(DocumentEvent e) {
            try {
                String text = e.getDocument().getText(0, e.getDocument().getLength());
                if (text.isEmpty()) {
                    text = null;
                }
                Object old = tupleData.get(labelField);
                tupleData.put(labelField, text);
                firePropertyChange(labelField, old, text);
            } catch (BadLocationException ex) {
                Exceptions.printStackTrace(ex);
            }
//            firePropertySetsChange(null, getPropertySets());
        }
    }
}
